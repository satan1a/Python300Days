# 深入理解 装饰器
- 装饰器本身就是一个函数（或者类），我们把 真正的业务逻辑函数 包裹在其中。

- 最终达到的效果是：我们不用修改 业务逻辑函数，调用时也只需要直接调用，但是我们的业务逻辑函数会执行装饰器中的内容。

- 装饰器 返回一个内部函数，这个函数内又返回我们的业务逻辑函数。<br />相当于：对象 -> 修饰器内部函数；修饰器内部函数 -> 业务逻辑函数；从而 对象 -> 业务逻辑函数。 <br />而外面套的修饰器内部函数则可以为我们提供额外的功能。

- @语法糖的作用是，免去 对象赋值给修饰器(传入业务逻辑函数) 的过程

- 装饰器返回的 内部函数可以接收参数：<br />*args 接受多个参数，arg 是一个数组<br />**kwargs 接受多个关键词参数(即已经赋值的，当作关键字使用的) kwargs 是一个字典

- 装饰器本身也可以带参数，最外层装饰器接收参数，里面则是对原有装饰器的封装

- 装饰器不仅可以是函数，还可以是类，可附加在函数上<br />相比函数装饰器，类装饰器具有 灵活度大、高内聚、封装性等优点<br />使用类装饰器主要依靠类的 __call__ 方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法

- unctools.wraps<br />wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。元信息比如：docstring(\_\_doc\_\_)、\_\_name\_\_

- 装饰器顺序<br/>一个方法可以同时定义多个装饰器<br />执行顺序：从内到外